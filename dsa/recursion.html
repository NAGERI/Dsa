<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
    <meta name="description" content="">
    <meta name="author" content="">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <!-- Bootstrap -->
    <link rel="stylesheet" href="./static/bootstrap.min.css">
    <!-- Font-Awesome -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <!-- styles sheet -->
    <link rel="stylesheet" type="text/css" href="static/css/style.css">
    
   
    <title>DATA STRUCTURES</title>
</head>
<body class="container-fluid col-lg-12 col-sm-12 col-xm-12" style="background-color: #fcfcfc">
	<nav class="navbar navbar-inverse">
		<div class="container-fluid">
		  <!-- Brand and toggle get grouped for better mobile display -->
		  <div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
			  <span class="sr-only">Toggle navigation</span>
			  <span class="icon-bar"></span>
			  <span class="icon-bar"></span>
			  <span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="index.html">CSC 2100 |  HOME</a>
		  </div>
		  
		  <!-- Collect the nav links, forms, and other content for toggling -->
		  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
			  <!-- <li class="active"><a href="#">CSC 2100 |  HOME<span class="sr-only">(current)</span></a></li> -->
			  <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Datastructures
				<span class="caret"></span></a>
				<ul class="dropdown-menu" role="menu">
				  <li><a href="#">Arrays</a></li>
				  <li><a href="#">Queues</a></li>
				  <li><a href="#">Stacks</a></li>
				  <li><a href="#">Lists</a></li>
				</ul>
			  </li>
			  <li class="nav-item">
				<a class="nav-link" href="algorithm.html">Algorithm analysis</a>
			  </li>
			   <li class="nav-item">
				<a class="nav-link" href="recursion.html">Recursion</a>
			  </li>
			  <li class="nav-item">
				<a class="nav-link" href="induction.html">Induction</a>
			  </li>
			  <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">More data structures
				<span class="caret"></span></a>
				<ul class="dropdown-menu" role="menu">
				  <li><a href="#">Linked Lists</a></li>
				  <li><a href="#">Priority Queue</a></li>
				</ul>
			  </li>
			  <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Sorting
				<span class="caret"></span></a>
				<ul class="dropdown-menu" role="menu">
				  <li><a href="#">Merge Sort</a></li>
				  <li><a href="#">Quick Sort</a></li>
				  <li><a href="#">Bubble Sort</a></li>
				  <li><a href="#">Insertion Sort</a></li>
				  <li><a href="#">Selection Sort</a></li>
				</ul>
			  </li>
			  <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Searching
				<span class="caret"></span></a>
				<ul class="dropdown-menu" role="menu">
				  <li><a href="#">Binary Search</a></li>
				  <li><a href="#">Linear Search</a></li>
				</ul>
			  </li>
			  
			</ul>
		  </div><!-- /.navbar-collapse -->
		</div><!-- /.container-fluid -->
	  </nav>
    <div class="container-fluid">
      <div class="row">
      	<div class="col-sm-1"></div>
      	<div class="col-sm-10">
      		<!-- <progress value="69" max="100">maximum</progress><br> -->
	
			<h1>RECURSION</h1>
			<br>
				<div class="row">
					<h4>
					<b><i>Recursion</i></b> is a programming technique in which a method calls itself, that is, a method is defined interms of itself.
				</h4>
				<p>
					A recursive function can go infinite like a loop.To avoid infinite running of recursive function, there are two properties that a recursive function must have:
					<ul>
						<li>Base criteria/case <b>−</b> There must be at least one base criteria or condition, such that, when this condition is met the function stops calling itself recursively.
						</li>
						<li>Progressive approach <b>−</b> The recursive calls should progress in such away that each time a recursive call is made it comes closer to the base criteria.</li>
					</ul>
				</p>
				</div>
				<div class="row">
					<h4>Characteristics of recursive methods.</h4>
					<p>
						<ul>
							<li>The recursive method calls itself to solve a smaller problem.</li>
							<li>The base case is the smallest problem that the routine solves and the value is returned to the calling method.</li>
							<li>Calling a method involves certain overhead in transferring the control to the beginning of the method and in storing the information of the return poin.</li>
							<li>Memory is used to store all the intermediate arguments and return values on the internal stack.</li>
						</ul>
					</p>
					<p>
						<h4> There is also Direct and Indirect recursion</h4>
						<ul>
							<li><b>Direct recursion</b> occurs when a method invokes itself.</li>
							<li><b>Indirect recursion</b> occurs when a method invokes another method, eventually resulting in the original method being invoked again</li>
						</ul>
					</p>
				</div>
				<div class="row">
					<p>A recursive algorithm is an algorithm which calls itself with "smaller (or simpler)" input values, and which obtains the result for the current input by applying simple operations to the returned value for the smaller (or simpler) input. More generally if a problem can be solved utilizing solutions to smaller versions of the same problem, and the smaller versions reduce to easily solvable cases, then one can use a recursive algorithm to solve that problem. For example, the elements of a recursively defined set, or the value of a recursively defined function can be obtained by a recursive algorithm. </p> &nbsp;

					<p>If a set or a function is defined recursively, then a recursive algorithm to compute its members or values mirrors the definition. Initial steps of the recursive algorithm correspond to the basis clause of the recursive definition and they identify the basis elements. They are then followed by steps corresponding to the inductive clause, which reduce the computation for an element of one generation to that of elements of the immediately preceding generation. </p> &nbsp;

					<p>In general, <em>recursive computer programs require more memory and computation compared with iterative algorithms, but they are simpler and for many cases a natural way of thinking about the problem.</em></p>
				</div>
				<div class="row">
					
						Example 1: Algorithm for finding the k<sup>th</sup> even natural number 
						<br>
						Note here that this can be solved very easily by simply outputting <b>2*(k - 1)</b> for a given k . The purpose here, however, is to illustrate the basic idea of recursion rather than solving the problem. 
						<br>
					
					<pre>
						Algorithm 1:   Even(positive integer k) 
							Input: k , a positive integer 
							Output: k<sup>th</sup> even natural number (the first even being 0) 

							Algorithm: 
							if (k = 1)
									then return 0; 
							else
								return Even(k-1) + 2 . 
					</pre>
					
				</div>	
				<div class="row">
					Here the computation of <b>Even (k)</b> is reduced to that of Even for a smaller input value, that is <b>Even(k-1)</b>. <b>Even(k)</b> eventually becomes <b>Even(1)</b> which is 0 by the first line. For example, to compute Even(3), Algorithm Even(k) is called with k = 2. In the computation of Even(2), Algorithm Even(k) is called with k = 1. Since Even(1) = 0, 0 is returned for the computation of Even(2), and Even(2) = Even(1) + 2 = 2 is obtained. This value 2 for Even(2) is now returned to the computation of Even(3), and Even(3) = Even(2) + 2 = 4 is obtained. <br>
					As can be seen by comparing this algorithm with the recursive definition of the set of nonnegative even numbers, the first line of the algorithm corresponds to the basis clause of the definition, and the second line corresponds to the inductive clause. 
					<br>
					By way of comparison, let us see how the same problem can be solved by an <em>iterative algorithm</em>
					<br> 
					<br>
				    <pre >
						Algorithm 1-a:   Even(positive integer k) 
							Input: k, a positive integer 
							Output: k<sup>th</sup> even natural number (the first even being 0) 

							Algorithm: 

							int   i, even; 
							i := 1;
							even := 0;
							while( i < k ) { 
									even := even + 2; 
									i := i + 1; 
							} 
							return even . 
					</pre>
	
				</div>	
				<br>
				<br>
					<hr>
					<SCRIPT LANGUAGE="JavaScript">

						function factorial(n) {
									if (n > 0) {
										return n * (factorial(n - 1))
									} else {
											return 1
										}
									}
									// function for sum of n numbers

						function sum_of_n(x){
							var n = x;
								if(n>1){
									return (Number(n) + Number(sum_of_n(n - 1))); 
								}

								else{
									return n;
								}
						}
						function fibonacci(n){
							if (n == 0) {
								return n 
								}
								else if (n == 1) {
								return n 
								}
							else{
								return fibonacci(n-2) + fibonacci(n-1)  
							}
						}

					</SCRIPT>
					<div class="row">
						<div class="col-lg-4 col-md-4 col-sm-4 col-xs-4">
									<p><b>Example for <em>FACTORIAL</em> :</b></p>
								<p>Input any value to obtain it's factorial </p>
							<br>
							<FORM>
								Enter an input value: <INPUT TYPE = "text" NAME="input" VALUE=0>
								<P><INPUT TYPE="button" VALUE="Calculate Factorial"onClick="this.form.output.value = factorial(this.form.input.value)">
								<P>Results: <INPUT TYPE="text" NAME="output">
							</FORM>
						</div>
						<div class="col-lg-4 col-md-4 col-sm-4 col-xs-4">
							<p><b>Example for <em>SUM</em> :</b></p>
								<p>Input any value, n, to obtain the sum of n numbers</p>
							<br>
							<FORM>
								Enter an input value: <INPUT TYPE = "text" NAME="input" VALUE=0>
								<P><INPUT TYPE="button" VALUE="Calculate sum_of_n"onClick="this.form.output.value = sum_of_n(this.form.input.value)">
								<P>Results: <INPUT TYPE="text" NAME="output">
							</FORM>
						</div>
						<div class="col-lg-4 col-md-4 col-sm-4 col-xs-4">
							<p><b>Example for <em>FIBONACCI</em> :</b></p>
								<p>Input any value, n, to obtain the n<sup>th</sup> number in fibonacci series</p>
							<br>
							<FORM>
								Enter an input value: <INPUT TYPE = "text" NAME="input" VALUE=0>
								<P><INPUT TYPE="button" VALUE="Return the nth fibonacci"onClick="this.form.output.value = fibonacci(this.form.input.value)">
								<P>Results: <INPUT TYPE="text" NAME="output">
							</FORM>
						</div>
						
					</div>
					<hr>
				<div>
									
					<h2>Tower of Hanoi :Algorithm</h2>
					<p>Tower of Hanoi, is a mathematical puzzle which consists of three towers (pegs) and more than one rings is as depicted</p>

					 <p>These rings are of different sizes and stacked upon in an ascending order, i.e. the smaller one sits over the larger one. There are other variations of the puzzle where the number of disks increase, but the tower count remains the same.</p>
					<h6>Tower of Hanoi puzzle with n disks can be solved in minimum 2n−1 steps. </h6>
					It can be implemented using a recursive algorithm

					The key to solving a problem recursively is to recognize that it can be broken down into a collection of smaller sub-problems, to each of which that same general solving procedure that we are seeking applies, and the total solution is then found in some simple way from those sub-problems' solutions. Each of thus created sub-problems being "smaller" guarantees that the base case(s) will eventually be reached. Thence, for the Towers of Hanoi:<br>
					 <p>
						label the pegs <b>A, B, C,</b>
						<br>
						let <b>n</b> be the total number of disks,
						<br>
						number the disks from 1 (smallest, topmost) to <b>n</b> (largest, bottom-most).
						<br>
						Assuming all <b>n</b> disks are distributed in valid arrangements among the pegs; 
						assuming there are <b>m</b> top disks on a source peg, and all the rest of the disks are larger than <b>m</b>, so they can be safely ignored; 
						to move <b>m</b> disks from a source peg to a target peg using a spare peg, without violating the <strong><em>rules</em></strong> 
						<ol type="i" style="background-color: #a7bce4; padding: 30px;" >
						    <li >Only one disk can be moved among the towers at any given time.</li>
						    <li>Only the "top" disk can be removed.</li>
						    <li>No large disk can sit over a small disk.</li>
						 </ol>
					</p>
						<p>
							<ol>
								<li>Move <b>m − 1</b> disks from the source to the spare peg, by the same general solving procedure. Rules are not violated, by assumption. This leaves the disk m as a top disk on the source peg.
								<br>
								<li>Move the <b>m<sup>th</sup></b> disk from the source to the target peg, which is guaranteed to be a valid move, by the assumptions — a simple step.<br>
								<li>Move the <b>m − 1</b> disks that we have just placed on the spare, from the spare to the target peg by the same general solving procedure, so they are placed on top of the disk <b>m</b> without violating the rules.
								<br>
							</ol>
								The base case being to move 0 disks (in steps 1 and 3), that is, do nothing – which obviously doesn't violate the rules.
								<br>
								The full Tower of Hanoi solution then consists of moving <b>n</b> disks from the source peg <b>A</b> to the target/destination peg <b>C</b>, using <b>B</b> as the spare/auxillary peg.
						</p>
						<h6>A recursive algorithm for Tower of Hanoi can be driven as follows −</h6>
						<br>
						<b>START</b>
						<br>
						Procedure Hanoi (disk, source, dest, aux)
						<br>
						 &nbsp;  IF disk == 1, THEN
						   <br>
						   &nbsp;&nbsp;&nbsp;   move disk from source to dest
						    <br>             
						  &nbsp; ELSE
						   <br>
						    &nbsp;&nbsp;&nbsp;  Hanoi(disk - 1, source, aux, dest)&nbsp;&nbsp;&nbsp;     // Step 1
						      <br>
						    &nbsp;&nbsp;&nbsp;  move disk from source to dest &nbsp;&nbsp;&nbsp;         // Step 2
						      <br>
						     &nbsp;&nbsp;&nbsp; Hanoi(disk - 1, aux, dest, source)  &nbsp;&nbsp;&nbsp;   // Step 3
						      <br>
						  &nbsp; END IF
						   <br>
						END Procedure
						<br>
						<b>STOP</b></bSTOP>
						<br>
					<h3>Illustration of a recursive solution for the Towers of Hanoi puzzle with 4 disks and another having 6 disks</h3>
					<br>
						<div class="row">
							<img src="static/images/hanoi.png" style="height: 700px; margin-right: 100px;" alt="hanoi tower ">
							<img src="static/images/2.gif" style="height: 700px; width: 450px;" alt="Gif image for solving the hanoi tower problem">
						</div>
				</div>

        </div>
      	<div class="col-sm-1"></div>
      </div>

<footer class="footer col-lg-12 col-xm-12 col-sm-12" id="footer">
		<h6>CONTACTS US ON :  </h6></b>
		  <b>
		    <a href="https://www.whatsapp" style="color: #25D366 "><i class="fab fa-whatsapp">&nbsp;WHATSAPP</i></a>  &nbsp;&nbsp;
		    <a href="https://www.facebook.com" style="color: #3b5999"><i class="fab fa-facebook-square">&nbsp;FACEBOOK</i></a> &nbsp;&nbsp;
		    <a href="https://www.twitter.com" style="color: #55acee" ><i class="fab fa-twitter-square">&nbsp;TWITTER</i></a> &nbsp;&nbsp;
		    <a href="https://www.linkedin.com " style=" color: #0077B5"><i class="fab fa-linkedin">&nbsp;LINKEDIN</i></a> &nbsp;&nbsp;
		  </b>
		  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  &reg;All rights reserved,  &nbsp;&nbsp;  2018 &copy; Group Two | Computer Science | Datastructures and Algorithms.
		 
		</footer>

<!-- Javascript -->
<script src="./static/jquery.min.js.download" type="text/javascript"></script>
<script src="./static/bootstrap.min.js.download" type="text/javascript"></script>


</body>
</html>